<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Slow Binsu 3D</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #87CEEB; 
            font-family: 'Segoe UI', sans-serif; touch-action: none;
        }
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10; display: flex; flex-direction: column;
            justify-content: space-between;
        }
        #score-board {
            padding: 20px; color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-size: 30px; font-weight: bold; text-align: center;
        }
        #menu {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; pointer-events: auto; background: rgba(0,0,0,0.7);
            padding: 40px; border-radius: 15px; border: 2px solid white;
        }
        h1 { color: #fff; margin: 0 0 20px 0; font-size: 40px; }
        button {
            padding: 15px 40px; font-size: 24px; background: #2ecc71; color: white;
            border: none; border-radius: 8px; cursor: pointer; font-weight: bold;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); text-transform: uppercase;
        }
        button:hover { background: #27ae60; }
        .crash-text { color: #e74c3c; font-size: 30px; font-weight: bold; margin-bottom: 20px; display: none;}
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="ui-layer">
        <div id="score-board">Distance: 0m</div>
        <div id="menu">
            <div id="crash-msg" class="crash-text">CRASHED!</div>
            <h1>Slow Binsu 3D</h1>
            <button id="start-btn">Drive</button>
        </div>
    </div>

<script>
// --- 1. SETUP THREE.JS SCENE ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB); // Sky blue
scene.fog = new THREE.Fog(0x87CEEB, 30, 150); // Fog for depth/horizon

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
// Position camera slightly behind and above the player
camera.position.set(0, 5, 10);
camera.lookAt(0, 0, -20);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- 2. LIGHTING ---
const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(10, 20, 10);
scene.add(dirLight);

// --- 3. LOAD TEXTURES ---
const textureLoader = new THREE.TextureLoader();
textureLoader.setCrossOrigin('anonymous');

const binsuTex = textureLoader.load('https://raw.githubusercontent.com/thesaching/flappy-binsu-game/refs/heads/main/binsuu.jpeg');
const friend1Tex = textureLoader.load('https://raw.githubusercontent.com/thesaching/flappy-binsu-game/refs/heads/main/all1u.jpeg');
const friend2Tex = textureLoader.load('https://raw.githubusercontent.com/thesaching/flappy-binsu-game/refs/heads/main/all2u.jpeg');

// --- 4. BUILD THE WORLD ---
// The Ground (Grass)
const groundGeo = new THREE.PlaneGeometry(500, 500);
const groundMat = new THREE.MeshLambertMaterial({ color: 0x27ae60 });
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
scene.add(ground);

// The Road
const roadGeo = new THREE.PlaneGeometry(16, 500);
const roadMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
const road = new THREE.Mesh(roadGeo, roadMat);
road.rotation.x = -Math.PI / 2;
road.position.y = 0.01; // Slightly above ground to prevent z-fighting
scene.add(road);

// The Player (Binsu Cube)
const playerSize = 2;
const playerGeo = new THREE.BoxGeometry(playerSize, playerSize, playerSize);
const playerMat = new THREE.MeshLambertMaterial({ map: binsuTex });
const playerMesh = new THREE.Mesh(playerGeo, playerMat);
playerMesh.position.y = playerSize / 2;
scene.add(playerMesh);

// --- 5. GAME VARIABLES ---
let gameState = 'IDLE';
let speed = 0.5; // Forward speed
let distance = 0;
let obstacles = [];
let targetX = 0; // Where the player is steering towards

// Lanes: Left, Center, Right
const lanes = [-5, 0, 5]; 

// --- 6. GAME LOGIC ---
function spawnObstacle() {
    // Pick a random lane
    const laneX = lanes[Math.floor(Math.random() * lanes.length)];
    
    // Choose friend texture
    const tex = Math.random() > 0.5 ? friend1Tex : friend2Tex;
    
    const obsGeo = new THREE.BoxGeometry(2.5, 2.5, 2.5);
    const obsMat = new THREE.MeshLambertMaterial({ map: tex });
    const obsMesh = new THREE.Mesh(obsGeo, obsMat);
    
    obsMesh.position.set(laneX, 1.25, -150); // Spawn far in the distance
    
    scene.add(obsMesh);
    obstacles.push(obsMesh);
}

function resetGame() {
    distance = 0;
    speed = 0.4;
    targetX = 0;
    playerMesh.position.x = 0;
    
    // Remove old obstacles
    obstacles.forEach(obs => scene.remove(obs));
    obstacles = [];
    
    document.getElementById('score-board').innerText = 'Distance: 0m';
    document.getElementById('menu').style.display = 'none';
    document.getElementById('crash-msg').style.display = 'none';
    
    gameState = 'PLAYING';
}

function gameOver() {
    gameState = 'GAMEOVER';
    document.getElementById('menu').style.display = 'block';
    document.getElementById('crash-msg').style.display = 'block';
    document.getElementById('start-btn').innerText = 'TRY AGAIN';
}

// --- 7. ANIMATION LOOP ---
function animate() {
    requestAnimationFrame(animate);

    if (gameState === 'PLAYING') {
        // Move player side-to-side smoothly
        playerMesh.position.x += (targetX - playerMesh.position.x) * 0.1;
        
        // Tilt the player slightly when steering
        playerMesh.rotation.z = (playerMesh.position.x - targetX) * 0.05;
        
        // Increase distance and speed
        distance += speed;
        speed += 0.0001; // Slowly accelerate over time
        
        if (Math.floor(distance) % 10 === 0) {
            document.getElementById('score-board').innerText = `Distance: ${Math.floor(distance / 10)}m`;
        }

        // Spawn obstacles randomly based on distance traveled
        if (Math.random() < 0.02 + (speed * 0.02)) {
            spawnObstacle();
        }

        // Update Obstacles (The Treadmill Effect)
        for (let i = obstacles.length - 1; i >= 0; i--) {
            let obs = obstacles[i];
            
            // Move obstacle towards player
            obs.position.z += speed;
            
            // Collision Detection (Simple Box collision)
            const dx = Math.abs(playerMesh.position.x - obs.position.x);
            const dz = Math.abs(playerMesh.position.z - obs.position.z);
            
            if (dx < playerSize && dz < playerSize) {
                gameOver();
            }
            
            // Remove if past camera
            if (obs.position.z > 15) {
                scene.remove(obs);
                obstacles.splice(i, 1);
            }
        }
    }

    renderer.render(scene, camera);
}

// --- 8. CONTROLS ---
window.addEventListener('keydown', (e) => {
    if (gameState !== 'PLAYING') return;
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
        targetX = Math.max(targetX - 5, -5); // Move left a lane
    }
    if (e.code === 'ArrowRight' || e.code === 'KeyD') {
        targetX = Math.min(targetX + 5, 5); // Move right a lane
    }
});

// Mobile Controls (Tap left/right side of screen)
window.addEventListener('touchstart', (e) => {
    if (gameState !== 'PLAYING') return;
    const touchX = e.touches[0].clientX;
    if (touchX < window.innerWidth / 2) {
        targetX = Math.max(targetX - 5, -5);
    } else {
        targetX = Math.min(targetX + 5, 5);
    }
});

// Resize handler
window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
});

document.getElementById('start-btn').addEventListener('click', resetGame);

// Start loop
animate();
</script>
</body>
</html>
